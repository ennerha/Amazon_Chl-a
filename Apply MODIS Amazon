# ============================================================
# AMAZÔNIA — MODIS (JUNHO/2022) — Pipeline NATIVO (rápido)
#  • 100% nativo no sistema do MODIS (sinusoidal ~463 m)
#  • Sem reprojeção no Earth Engine e SEM reprojeção local
#  • Sem exclusão de dados/arquivos (mantém tudo que gerar)
#  • Terra+Aqua adaptativo, tiles grandes, paralelismo
#  • Saída: GeoTIFF nativo (sinusoidal) com photometric=MINISBLACK
#  • Visual rápido (preview) + média mensal (mg m^-3)
# ============================================================

import os, io, zipfile, time, warnings, sys, subprocess, importlib, json, pickle, logging
from pathlib import Path
import numpy as np
import matplotlib; matplotlib.use("Agg")
import matplotlib.pyplot as plt
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

# ---------------------------------- Auto-instalação leve ----------------------------------
def _ensure(pkg, imp=None):
    name = imp or pkg.split('==')[0].split('>=')[0]
    try:
        importlib.import_module(name)
    except Exception:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", pkg])

for pkg, imp in [
    ("earthengine-api>=1.0.0","ee"),
    ("rasterio>=1.3.9","rasterio"),
    ("geopandas>=0.14","geopandas"),
    ("shapely>=2.0","shapely"),
    ("fiona>=1.9","fiona"),
    ("pyproj>=3.5","pyproj"),
    ("joblib>=1.2","joblib"),
    ("requests>=2.31","requests"),
    ("tqdm>=4.66","tqdm"),
]:
    try:
        importlib.import_module(imp)
    except Exception:
        _ensure(pkg, imp)

import ee, requests, joblib, geopandas as gpd, fiona, rasterio as rio
from rasterio.merge import merge as rio_merge
from rasterio.warp import transform_geom
from rasterio.features import rasterize
from shapely.geometry import (box, mapping, Polygon, MultiPolygon, GeometryCollection)
from shapely.ops import unary_union
from shapely.validation import make_valid
from tqdm import tqdm

warnings.filterwarnings("ignore")
logging.getLogger("rasterio._env").setLevel(logging.ERROR)
os.environ["CPL_DEBUG"] = "OFF"

# ---------------------------------- CONFIG ----------------------------------
START_YEAR = 2022
END_YEAR   = 2022
MONTHS_TO_PROCESS = [6]

PAD_DAYS   = 2
COMPOSITE  = "median"

EE_PROJECT = os.environ.get("EE_PROJECT", "ee-enneralcantarabariri")
SHP_PATH   = "/content/Hydro_lakes_AM_basin.shp"

# tiles grandes = menos chamadas HTTP (aumente se quiser ainda mais rápido)
TILE_DEG      = float(os.environ.get("TILE_DEG", "3.0"))

USE_TERRA_AQUA_ADAPTIVE = True
CLEAR_THRESHOLD = 0.45

# Modelo
MODEL_PATH    = "/content/artifacts_amazonia/amazonia_svr_global.pkl"
PRED_INVERSE  = "ln1p"
NODATA_PRED   = -9999.0

# Paralelismo (ajuste conforme máquina)
MAX_WORKERS       = int(os.environ.get("DL_THREADS", "6"))        # downloads (I/O)
PROCESS_WORKERS   = int(os.environ.get("CPU_PROCS", "4"))         # predição (CPU)

# Pastas
ART_DIR  = Path("/content/artifacts_amazonia_modis"); ART_DIR.mkdir(exist_ok=True, parents=True)
FEATURES_DIR = ART_DIR/"features"; FEATURES_DIR.mkdir(exist_ok=True, parents=True)
TMP_DIR  = ART_DIR/"tmp"; TMP_DIR.mkdir(exist_ok=True, parents=True)
PRED_DIR = ART_DIR/"pred"; PRED_DIR.mkdir(exist_ok=True, parents=True)
PLOT_DIR = ART_DIR/"plots"; PLOT_DIR.mkdir(exist_ok=True, parents=True)
CACHE_DIR = ART_DIR/"cache"; CACHE_DIR.mkdir(exist_ok=True, parents=True)

SR_BANDS = ["sur_refl_b01","sur_refl_b02","sur_refl_b03",
            "sur_refl_b04","sur_refl_b05","sur_refl_b06","sur_refl_b07"]

def info(x): print(f"[INFO] {x}")
def err(x):  print(f"[ERROR] {x}")

# ---------------------------------- Helpers ROI (robustos p/ 2D/3D) ----------------------------------
def _ring_xy_closed(coords, ndigits=6):
    """Aceita coords 2D/3D (x,y[,z]); arredonda, remove duplicados e fecha anel."""
    out = []
    for c in coords:
        if c is None:
            continue
        try:
            x = float(c[0]); y = float(c[1])
        except Exception:
            continue
        x = round(x, ndigits); y = round(y, ndigits)
        if not out or (x, y) != out[-1]:
            out.append((x, y))
    if not out:
        return []
    if out[0] != out[-1]:
        out.append(out[0])
    return out if len(out) >= 4 else []

def _poly_to_coords(poly, ndigits=6, max_vertices=5000):
    """Converte Polygon em lista de anéis [[ext], [hole1], ...]; simplifica se exceder max_vertices."""
    if poly is None or poly.is_empty or poly.exterior is None:
        return []
    def _rings_from(p):
        ext = _ring_xy_closed(list(p.exterior.coords), ndigits)
        if not ext:
            return []
        holes = []
        for r in p.interiors:
            rr = _ring_xy_closed(list(r.coords), ndigits)
            if rr:
                holes.append(rr)
        return [ext] + holes

    rings = _rings_from(poly)
    total = sum(len(r) for r in rings)
    tol = 0.0
    while rings and total > max_vertices:
        tol = max(tol*2, 1e-6)  # 1e-6, 2e-6, 4e-6...
        simp = poly.simplify(tol, preserve_topology=True)
        if simp is None or simp.is_empty or simp.exterior is None:
            break
        rings = _rings_from(simp)
        total = sum(len(r) for r in rings)
        if tol > 1e-2:
            break
    return rings

def multipolygon_to_ee_geojson(geom, ndigits=6, max_vertices=5000):
    """Gera GeoJSON Polygon/MultiPolygon compatível com EE. Retorna None se não conseguir."""
    if geom is None or geom.is_empty:
        return None
    if isinstance(geom, Polygon):
        polys = [geom]
    elif isinstance(geom, MultiPolygon):
        polys = list(geom.geoms)
    else:
        return None

    all_poly_rings = []
    for p in polys:
        rings = _poly_to_coords(p, ndigits, max_vertices)
        if rings:
            all_poly_rings.append(rings)

    if not all_poly_rings:
        return None
    if len(all_poly_rings) == 1:
        return {"type": "Polygon", "coordinates": all_poly_rings[0]}
    return {"type": "MultiPolygon", "coordinates": all_poly_rings}

def sanitize_polygonal(geom):
    """Mantém apenas partes poligonais e corrige interseções claras."""
    if geom is None or geom.is_empty:
        return Polygon()
    try:
        geom = make_valid(geom)
    except Exception:
        geom = geom.buffer(0)
    polys = []
    if isinstance(geom, (Polygon, MultiPolygon)):
        polys = [geom] if isinstance(geom, Polygon) else list(geom.geoms)
    elif isinstance(geom, GeometryCollection):
        for gg in geom.geoms:
            if isinstance(gg, (Polygon, MultiPolygon)):
                polys.append(gg)
    if not polys:
        return Polygon()
    return unary_union(polys)

# ---------------------------------- EE init ----------------------------------
def ee_init():
    try:
        ee.Initialize(project=EE_PROJECT)
    except Exception:
        ee.Authenticate(auth_mode='notebook')
        ee.Initialize(project=EE_PROJECT)
    info(f"EE OK — project: {EE_PROJECT}")

# ---------------------------------- Processados ----------------------------------
def get_processed_months():
    processed = []
    if PRED_DIR.exists():
        for f in PRED_DIR.glob("amazonia_chla_*.tif"):
            try:
                year, month = f.stem.split("_")[-1].split("-")
                processed.append((int(year), int(month)))
            except:
                continue
    return set(processed)

# ---------------------------------- ROI (cache com migração e fallback bbox) ----------------------------------
def load_roi_local():
    roi_cache = CACHE_DIR / "roi_cache.pkl"
    if roi_cache.exists():
        try:
            with open(roi_cache, 'rb') as f:
                obj = pickle.load(f)
            if isinstance(obj, (list, tuple)) and len(obj) == 4:
                roi_gdf, roi_geom, roi_bbox_ee, roi_ee = obj
                info(f"ROI carregada do cache (v2): {roi_geom.bounds}")
                return roi_gdf, roi_geom, roi_bbox_ee, roi_ee
            if isinstance(obj, (list, tuple)) and len(obj) == 3:
                roi_gdf, roi_geom, roi_bbox_ee = obj
                roi_geom = sanitize_polygonal(roi_geom)
                ee_geo = multipolygon_to_ee_geojson(roi_geom)
                if ee_geo is None:
                    xmin,ymin,xmax,ymax = roi_geom.bounds
                    roi_ee = ee.Geometry.Rectangle([xmin,ymin,xmax,ymax], "EPSG:4326", False)
                else:
                    roi_ee = ee.Geometry(ee_geo, "EPSG:4326", False)
                with open(roi_cache, 'wb') as f2:
                    pickle.dump((roi_gdf, roi_geom, roi_bbox_ee, roi_ee), f2)
                info(f"ROI cache migrado para v2: {roi_geom.bounds}")
                return roi_gdf, roi_geom, roi_bbox_ee, roi_ee
            info("ROI cache em formato inesperado. Recriando...")
        except Exception as e:
            err(f"Falha ao ler cache da ROI ({e}). Recriando...")

    if not Path(SHP_PATH).exists():
        raise FileNotFoundError(f"Shapefile não encontrado: {SHP_PATH}")

    with fiona.Env(SHAPE_RESTORE_SHX='YES'):
        gdf = gpd.read_file(SHP_PATH)
    if gdf.crs is None or str(gdf.crs).upper() != "EPSG:4326":
        gdf = gdf.to_crs("EPSG:4326")

    geoms = []
    for geom in gdf.geometry:
        if geom is None or geom.is_empty:
            continue
        try:
            gv = make_valid(geom)
        except Exception:
            gv = geom.buffer(0)
        if not gv.is_empty:
            geoms.append(gv)

    if not geoms:
        raise ValueError("ROI sem geometrias válidas no shapefile.")

    uni_raw = unary_union(geoms)
    uni = sanitize_polygonal(uni_raw)
    if uni is None or uni.is_empty:
        raise ValueError("ROI união vazia após saneamento.")

    xmin,ymin,xmax,ymax = uni.bounds
    roi_bbox_ee = ee.Geometry.Rectangle([xmin,ymin,xmax,ymax], "EPSG:4326", False)
    ee_geo = multipolygon_to_ee_geojson(uni)
    if ee_geo is None:
        info("ROI poligonal muito complexa; usando bbox como fallback.")
        roi_ee = roi_bbox_ee
    else:
        roi_ee = ee.Geometry(ee_geo, "EPSG:4326", False)

    roi_gdf = gpd.GeoDataFrame(geometry=[uni], crs="EPSG:4326")
    with open(roi_cache, 'wb') as f:
        pickle.dump((roi_gdf, uni, roi_bbox_ee, roi_ee), f)
    info(f"ROI bounds: {uni.bounds}")
    return roi_gdf, uni, roi_bbox_ee, roi_ee

# ---------------------------------- Tiles ----------------------------------
def tiles_rects(bounds, step_deg):
    xmin,ymin,xmax,ymax = bounds
    xs = np.arange(np.floor(xmin/step_deg)*step_deg, np.ceil(xmax/step_deg)*step_deg, step_deg)
    ys = np.arange(np.floor(ymin/step_deg)*step_deg, np.ceil(ymax/step_deg)*step_deg, step_deg)
    rects = []
    for x0 in xs:
        x1 = min(x0+step_deg, xmax)
        for y0 in ys:
            y1 = min(y0+step_deg, ymax)
            if x1<=x0 or y1<=y0:
                continue
            rects.append((float(x0), float(y0), float(x1), float(y1)))
    return rects

def filter_tiles_simple(roi_geom, rects):
    cand = [r for r in rects if box(*r).intersects(roi_geom)]
    info(f"Tiles válidos (intersecção ROI): {len(cand)}")
    return cand

# ---------------------------------- QA rápido+ ----------------------------------
def scale_qc_fast(img):
    sr = img.select(SR_BANDS).multiply(0.0001)
    band_names = img.bandNames()
    has_qc_500 = band_names.indexOf("sur_refl_qc_500m").neq(-1)
    has_state1 = band_names.indexOf("state_1km").neq(-1)

    def _mask_with_state_and_qc():
        qa = img.select("sur_refl_qc_500m")
        good_qc = qa.bitwiseAnd(3).lte(1)
        st = img.select("state_1km")
        cloud_state = st.bitwiseAnd(3)     # bits 0-1
        clear = cloud_state.eq(0)
        return sr.updateMask(good_qc.And(clear))

    def _mask_with_qc_only():
        qa = img.select("sur_refl_qc_500m")
        good_qc = qa.bitwiseAnd(3).lte(1)
        return sr.updateMask(good_qc)

    def _no_qc():
        return sr

    result = ee.Algorithms.If(
        has_state1, _mask_with_state_and_qc(),
        ee.Algorithms.If(has_qc_500, _mask_with_qc_only(), _no_qc())
    )
    return ee.Image(result).copyProperties(img, ['system:time_start'])

# ---------------------------------- Métricas e score ----------------------------------
def _valid_fraction(img, roi, band="sur_refl_b04"):
    valid = img.select(band).mask().rename('m')
    stats = valid.reduceRegion(ee.Reducer.mean(), roi, 1000, maxPixels=1e13)
    return ee.Number(stats.get('m'))

def _quality_score(img):
    band_names = img.bandNames()
    has_state1 = band_names.indexOf("state_1km").neq(-1)

    def with_state():
        st = img.select("state_1km")
        cloud_state = st.bitwiseAnd(3)
        score = (cloud_state.eq(0).multiply(1.0)
                 .add(cloud_state.eq(2).multiply(0.5))
                 .add(cloud_state.eq(1).multiply(0.0))
                 .add(cloud_state.eq(3).multiply(-1.0)))
        return score.rename("score")

    def no_state():
        b04 = img.select("sur_refl_b04")
        mn = ee.Number(0.01); mx = ee.Number(0.2)
        b04n = b04.subtract(mn).divide(mx.subtract(mn)).clamp(0,1)
        return ee.Image(1.0).subtract(b04n).rename("score")

    return ee.Image(ee.Algorithms.If(has_state1, with_state(), no_state()))

# ---------------------------------- Mosaico Terra+Aqua adaptativo ----------------------------------
def build_mosaic_month_adapt(roi_bbox_ee, year, month):
    start = ee.Date.fromYMD(year, month, 1)
    end   = start.advance(1, "month")
    if PAD_DAYS > 0:
        start = start.advance(-PAD_DAYS, "day")
        end   = end.advance(PAD_DAYS, "day")

    def coll(path):
        return (ee.ImageCollection(path)
                .filterDate(start, end)
                .filterBounds(roi_bbox_ee)
                .map(scale_qc_fast))

    try:
        terra = coll("MODIS/061/MOD09A1")
    except Exception:
        terra = coll("MODIS/006/MOD09A1")

    terra_mos = (terra.select(SR_BANDS).median() if COMPOSITE == "median"
                 else terra.select(SR_BANDS).mean()).clip(roi_bbox_ee)

    frac_terra = _valid_fraction(terra_mos, roi_bbox_ee)

    if not USE_TERRA_AQUA_ADAPTIVE:
        return terra_mos, frac_terra

    def with_combo():
        try:
            aqua = coll("MODIS/061/MYD09A1")
        except Exception:
            aqua = coll("MODIS/006/MYD09A1")
        both = terra.merge(aqua)
        scored = both.map(lambda im: ee.Image(im.addBands(_quality_score(im))))
        qm = scored.qualityMosaic("score").select(SR_BANDS)
        mos = qm if COMPOSITE == "median" else scored.select(SR_BANDS).median()
        return mos.clip(roi_bbox_ee)

    mosaic_final = ee.Image(ee.Algorithms.If(frac_terra.lt(CLEAR_THRESHOLD),
                                             with_combo(), terra_mos))
    return mosaic_final, frac_terra

# ---------------------------------- Features ----------------------------------
def _lin_interp(img_low, wl_low, img_high, wl_high, wl_target):
    frac = (wl_target - wl_low) / (wl_high - wl_low + 1e-12)
    return img_low.add(img_high.subtract(img_low).multiply(frac))

def build_features_image_fast(mosaic, feature_names):
    eps = ee.Image.constant(1e-12)
    zero_scalar = ee.Image.constant(0)

    base = {b: mosaic.select(b) for b in SR_BANDS}
    b03 = base.get("sur_refl_b03")
    b04 = base.get("sur_refl_b04")
    b01 = base.get("sur_refl_b01")

    Rrs_560 = b04
    Rrs_490 = _lin_interp(b03, 469.0, b04, 555.0, 490.0) if (b03 is not None and b04 is not None) else None
    Rrs_510 = _lin_interp(b03, 469.0, b04, 555.0, 510.0) if (b03 is not None and b04 is not None) else None
    Rrs_443 = (_lin_interp(b03, 469.0, b04, 555.0, 443.0).max(zero_scalar)
               if (b03 is not None and b04 is not None) else None)
    Rrs_620 = _lin_interp(b04, 555.0, b01, 645.0, 620.0) if (b01 is not None and b04 is not None) else None
    Rrs_665 = _lin_interp(b04, 555.0, b01, 645.0, 665.0) if (b01 is not None and b04 is not None) else None
    Rrs_709 = _lin_interp(b04, 555.0, b01, 645.0, 709.0) if (b01 is not None and b04 is not None) else None

    proxies = {"Rrs_443": Rrs_443, "Rrs_490": Rrs_490, "Rrs_510": Rrs_510,
               "Rrs_560": Rrs_560, "Rrs_620": Rrs_620, "Rrs_665": Rrs_665, "Rrs_709": Rrs_709}

    L1 = mosaic.select(SR_BANDS).reduce(ee.Reducer.sum()).add(eps)

    def pick(stem):
        table = {
            **proxies,
            "G_over_B": (b04.divide(b03.add(eps)) if (b04 is not None and b03 is not None) else None),
            "B_over_R": (b03.divide(b01.add(eps)) if (b03 is not None and b01 is not None) else None),
            "NDCI": ((Rrs_709.subtract(b01)).divide(Rrs_709.add(b01).add(eps))
                     if (Rrs_709 is not None and b01 is not None) else None),
        }
        return table.get(stem, None)

    bands = []
    zero_img = mosaic.select(0).multiply(0)

    for fname in feature_names:
        img = pick(fname)

        if img is None and fname.endswith("_norm560"):
            stem = fname[:-8]; b = pick(stem)
            if b is not None and Rrs_560 is not None:
                img = b.divide(Rrs_560.add(eps))
        elif img is None and fname == "norm_Rrs_L1":
            img = L1
        elif img is None and fname.endswith("_normL1"):
            stem = fname[:-7]; b = pick(stem)
            if b is not None:
                img = b.divide(L1)

        if img is None:
            img = zero_img

        bands.append(img.rename(fname))

    return ee.Image.cat(bands)

# ---------------------------------- Download (rápido: nativo sinusoidal) ----------------------------------
def download_tiles_parallel(feats_im, rects, ym, native_scale, roi_ee=None):
    scale_val = float(native_scale)
    args = []
    for tid, rect in enumerate(rects):
        rect_ee = ee.Geometry.Rectangle(rect, proj="EPSG:4326", geodesic=False)
        region_ee = rect_ee if roi_ee is None else rect_ee.intersection(roi_ee, 1)
        out_tif = FEATURES_DIR / f"feats_{ym}_t{tid:03d}.tif"
        args.append((feats_im, region_ee, str(out_tif), scale_val))

    def _dl(arg):
        img, region_ee, out_path, scale_use = arg
        params = {
            "region": region_ee,
            "scale": scale_use,          # sem 'crs' -> usa proj nativa (sinusoidal) do MODIS
            "maxPixels": int(1e13),
            "format": "GEO_TIFF"
        }
        max_retries = 2
        for attempt in range(max_retries):
            try:
                url = img.getDownloadURL(params)
                r = requests.get(url, timeout=300, allow_redirects=True)
                r.raise_for_status()
                data = r.content
                if data[:2] == b'PK':
                    with zipfile.ZipFile(io.BytesIO(data)) as zf:
                        names = [n for n in zf.namelist() if n.lower().endswith(('.tif','.tiff'))]
                        if names:
                            with zf.open(names[0]) as zt, open(out_path, 'wb') as f:
                                f.write(zt.read())
                            return str(out_path)
                else:
                    with open(out_path, 'wb') as f:
                        f.write(data)
                    return str(out_path)
            except Exception as e:
                if attempt == max_retries - 1:
                    err(f"Download falhou após {max_retries} tentativas: {e}")
                else:
                    time.sleep(1)
        return None

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as ex:
        results = list(tqdm(ex.map(_dl, args), total=len(args), desc="Downloading tiles"))
    return [r for r in results if r is not None]

# ---------------------------------- Predição ----------------------------------
def predict_tile_fast(args):
    path_tif, roi_geom, model_data = args
    try:
        with rio.open(path_tif) as ds:
            arr = ds.read().astype("float32")
            height, width = ds.height, ds.width
            transform = ds.transform
            crs = ds.crs

        finite_all = np.isfinite(arr).all(axis=0)

        try:
            geoms_tx = [transform_geom("EPSG:4326", crs.to_string(), mapping(roi_geom), precision=6)]
            roi_m = rasterize([(g,1) for g in geoms_tx],
                              out_shape=(height, width),
                              transform=transform, fill=0,
                              all_touched=True, dtype="uint8").astype(bool)
        except Exception:
            roi_m = np.ones((height, width), dtype=bool)

        mask = finite_all & roi_m
        if not mask.any():
            return None

        B, H, W = arr.shape
        data = arr.reshape(B, -1).T
        valid_idx = mask.reshape(-1)

        y_log = np.full(data.shape[0], np.nan, dtype="float32")
        if valid_idx.any():
            X = data[valid_idx]
            finite = np.isfinite(X).all(axis=1)
            if finite.any():
                Xc = X[finite]
                valid_finite_idx = np.where(valid_idx)[0][finite]
                y_log[valid_finite_idx] = model_data["model"].predict(Xc).astype("float32")

        y_lin = np.expm1(y_log) if PRED_INVERSE == "ln1p" else y_log
        pred = y_lin.reshape(H, W).astype("float32")
        pred[~mask] = NODATA_PRED
        pred[~np.isfinite(pred)] = NODATA_PRED

        out_tile = TMP_DIR / f"pred_{Path(path_tif).stem}.tif"
        prof_out = {
            "driver": "GTiff",
            "height": H, "width": W, "count": 1,
            "dtype": "float32", "crs": crs, "transform": transform,
            "nodata": NODATA_PRED, "compress": "deflate",
            "photometric": "MINISBLACK"
        }
        with rio.open(out_tile, "w", **prof_out) as dst:
            dst.write(pred, 1)

        return str(out_tile)

    except Exception as e:
        err(f"Erro predição {path_tif}: {e}")
        return None

def predict_tiles_parallel(downloaded, roi_geom, M):
    predict_args = [(f, roi_geom, M) for f in downloaded]
    with ProcessPoolExecutor(max_workers=PROCESS_WORKERS) as executor:
        results = list(tqdm(executor.map(predict_tile_fast, predict_args),
                            total=len(predict_args), desc="Predicting tiles"))
    return [r for r in results if r is not None]

# ---------------------------------- Visualizações ----------------------------------
def preview_png_fast(tif_path):
    try:
        with rio.open(tif_path) as ds:
            arr = ds.read(1, out_shape=(max(1, ds.height//4), max(1, ds.width//4)))
            arr = np.ma.masked_equal(arr, ds.nodata)
        if arr.compressed().size == 0:
            return
        vmin, vmax = np.percentile(arr.compressed(), (5, 95))
        plt.figure(figsize=(6, 4))
        plt.imshow(arr, vmin=vmin, vmax=vmax, cmap="viridis")
        plt.colorbar(label="Chl-a (mg m$^{-3}$)", shrink=0.6)
        plt.title(Path(tif_path).name, fontsize=10)
        plt.axis('off')
        out = PLOT_DIR / f"preview_{Path(tif_path).stem}.png"
        plt.savefig(out, dpi=100, bbox_inches="tight")
        plt.close()
        info(f"Preview salvo em: {out}")
    except Exception as e:
        err(f"Preview error: {e}")

def compute_month_mean(tif_path, roi_geom):
    """Média mensal de Chl-a (mg m^-3) sobre a ROI — no CRS nativo."""
    try:
        with rio.open(tif_path) as ds:
            arr = ds.read(1)
            nodata = ds.nodata
            transform = ds.transform
            crs = ds.crs
            height, width = ds.height, ds.width
        try:
            geoms_tx = [transform_geom("EPSG:4326", crs.to_string(), mapping(roi_geom), precision=6)]
            roi_m = rasterize([(g,1) for g in geoms_tx],
                              out_shape=(height, width),
                              transform=transform, fill=0,
                              all_touched=True, dtype="uint8").astype(bool)
        except Exception:
            roi_m = np.ones((height, width), dtype=bool)
        m = roi_m & np.isfinite(arr) & ((nodata is None) | (arr != nodata))
        if not m.any():
            return np.nan
        return float(arr[m].mean())
    except Exception as e:
        err(f"Falha ao calcular média mensal: {e}")
        return np.nan

def plot_month_mean(mean_value, ym_str):
    try:
        plt.figure(figsize=(4,3))
        plt.bar([ym_str], [mean_value])
        plt.ylabel("Chl-a (mg m$^{-3}$)")
        plt.title(f"Média mensal: {ym_str}")
        out = PLOT_DIR / f"mean_{ym_str}.png"
        plt.savefig(out, dpi=110, bbox_inches="tight")
        plt.close()
        info(f"Gráfico de média salvo em: {out}")
    except Exception as e:
        err(f"Falha ao plotar média: {e}")

# ---------------------------------- MAIN ----------------------------------
def main():
    start_time = time.time()
    ee_init()

    # ROI pronta
    roi_gdf, roi_geom, roi_bbox_ee, roi_ee = load_roi_local()
    info(f"ROI pronta: {roi_geom.bounds}")

    # Modelo
    if not Path(MODEL_PATH).exists():
        raise FileNotFoundError(f"Modelo não encontrado: {MODEL_PATH}")
    M = joblib.load(MODEL_PATH)

    # Tiles (use TILE_DEG maior p/ menos tiles)
    rects_all = tiles_rects(roi_geom.bounds, TILE_DEG)
    rects = filter_tiles_simple(roi_geom, rects_all)
    info(f"Processando tiles de {TILE_DEG}° — total: {len(rects)}")

    # Meses pendentes
    processed = get_processed_months()
    months_todo = [(y, m) for y in range(START_YEAR, END_YEAR+1) for m in MONTHS_TO_PROCESS
                   if (y, m) not in processed]
    info(f"Meses a processar: {months_todo if months_todo else 'nenhum'}")
    if not months_todo:
        info("Nada a fazer.")
        return

    for idx, (year, month) in enumerate(months_todo, 1):
        ym = f"{year:04d}-{month:02d}"
        info(f"=== {ym} === ({idx}/{len(months_todo)})")
        out_final = PRED_DIR / f"amazonia_chla_{ym}.tif"   # nativo
        if out_final.exists():
            info(f"[{ym}] Já existe, pulando processamento.")
            preview_png_fast(out_final)
            mean_val = compute_month_mean(out_final, roi_geom)
            if np.isfinite(mean_val):
                info(f"[{ym}] MÉDIA mensal Chl-a: {mean_val:.3f} mg m^-3")
                plot_month_mean(mean_val, ym)
            continue

        try:
            # 1) Mosaico adaptativo + features
            t0 = time.perf_counter()
            mosaic, frac_terra = build_mosaic_month_adapt(roi_bbox_ee, year, month)
            feats_im = build_features_image_fast(mosaic, M["features"])

            # scale nativo (~463 m)
            mosaic_proj = mosaic.projection()
            try:
                native_scale = float(mosaic_proj.nominalScale().getInfo())
            except Exception:
                native_scale = 463.3127
            info(f"[{ym}] EE mosaic+features (nativo) em {(time.perf_counter()-t0):.1f}s; scale≈{native_scale:.2f} m")

            # 2) Download paralelo (NATIVO; sem reprojetar no EE)
            t1 = time.perf_counter()
            downloaded = download_tiles_parallel(feats_im, rects, ym, native_scale, roi_ee=roi_ee)
            info(f"[{ym}] Download: {(time.perf_counter()-t1):.1f}s; tiles OK: {len(downloaded)}")
            if not downloaded:
                err(f"[{ym}] Nenhum download bem-sucedido"); continue

            # 3) Predição paralela
            t2 = time.perf_counter()
            pred_tiles = predict_tiles_parallel(downloaded, roi_geom, M)
            info(f"[{ym}] Predição: {(time.perf_counter()-t2):.1f}s; tiles OK: {len(pred_tiles)}")
            if not pred_tiles:
                err(f"[{ym}] Nenhuma predição bem-sucedida"); continue

            # 4) Merge final — mantém CRS NATIVO (sinusoidal)
            t3 = time.perf_counter()
            srcs = [rio.open(p) for p in pred_tiles]
            mosaic_arr, mosaic_trans = rio_merge(srcs, nodata=NODATA_PRED)
            native_crs = srcs[0].crs
            for s in srcs: s.close()

            meta_native = {
                "driver": "GTiff",
                "height": mosaic_arr.shape[1], "width": mosaic_arr.shape[2],
                "count": 1, "dtype": mosaic_arr.dtype, "crs": native_crs,
                "transform": mosaic_trans, "nodata": NODATA_PRED,
                "compress": "lzw", "tiled": True, "photometric": "MINISBLACK",
                "blockxsize": 256, "blockysize": 256
            }
            with rio.open(out_final, "w", **meta_native) as dst:
                dst.write(mosaic_arr[0], 1)
            info(f"[{ym}] Merge (nativo): {(time.perf_counter()-t3):.1f}s")

            # 5) SEM LIMPEZA — mantém downloaded, pred_tiles e mosaico final nativo.

            # Visual e média mensal
            preview_png_fast(out_final)
            mean_val = compute_month_mean(out_final, roi_geom)
            if np.isfinite(mean_val):
                info(f"[{ym}] MÉDIA mensal Chl-a: {mean_val:.3f} mg m^-3")
                plot_month_mean(mean_val, ym)

        except Exception as e:
            err(f"[{ym}] Erro: {e}")
            continue

    total_time = (time.time() - start_time) / 3600
    info(f"CONCLUÍDO! Tempo total: {total_time:.2f} h")

# ---------------------------------- ENTRYPOINT ----------------------------------
if __name__ == "__main__":
    main()
